name: Deploy Next.js Application

on:
  push:
    branches:
      - main
      - production

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to Digital Ocean
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          passphrase: ${{ secrets.DO_SSH_PASSPHRASE }}
          script: |
            # Enable error handling
            set -e

            # Function for error handling
            handle_error() {
              echo "ERROR: Deployment failed at step: $1"
              exit 1
            }

            # Function to validate required secrets
            validate_required_secrets() {
              local missing_secrets=()
              
              # Check each required secret
              # Server access credentials 
              [ -z "${{ secrets.DO_HOST }}" ] && missing_secrets+=("DO_HOST")  # Digital Ocean server IP address or hostname
              [ -z "${{ secrets.DO_USERNAME }}" ] && missing_secrets+=("DO_USERNAME")  # SSH username for the server
              [ -z "${{ secrets.DO_SSH_KEY }}" ] && missing_secrets+=("DO_SSH_KEY")  # SSH private key for authentication
              # DO_SSH_PASSPHRASE is used in the SSH action config if the key has a passphrase (optional)
              
              # Project configuration
              [ -z "${{ secrets.PROJECT_NAME }}" ] && missing_secrets+=("PROJECT_NAME")  # Name of the project (used for directory and PM2 process)
              [ -z "${{ secrets.PROJECT_REPO }}" ] && missing_secrets+=("PROJECT_REPO")  # Git repository URL for the project
              [ -z "${{ secrets.PROJECT_DOMAIN }}" ] && missing_secrets+=("PROJECT_DOMAIN")  # Domain name for Nginx and SSL
              
              # Application configuration
              [ -z "${{ secrets.ENV_FILE }}" ] && missing_secrets+=("ENV_FILE")  # Content of the .env file for the app
              [ -z "${{ secrets.PM2_ENV_VARS }}" ] && missing_secrets+=("PM2_ENV_VARS")  # Additional environment variables for PM2
              
              # SSL configuration
              [ -z "${{ secrets.SSL_EMAIL }}" ] && missing_secrets+=("SSL_EMAIL")  # Email for Let's Encrypt SSL certificate
              
              # Optional: PM2_FILE_TYPE controls ecosystem file extension (defaults to 'cjs' if not set)
              
              # If any secrets are missing, print error and exit
              if [ ${#missing_secrets[@]} -gt 0 ]; then
                echo "ERROR: The following required secrets are missing:"
                printf "  - %s\n" "${missing_secrets[@]}"
                exit 1
              fi
              
              echo "âœ“ All required secrets are available"
            }

            # Validate secrets before proceeding
            validate_required_secrets

            # Function to find an available port or use the assigned one
            find_available_port() {
              local project_name=$1
              local preferred_port=$2
              local port_config_file="/var/www/port_mappings.json"
              local min_port=3000
              local max_port=4000
              
              # Create port mapping file if it doesn't exist
              if [ ! -f "$port_config_file" ]; then
                echo "{}" > "$port_config_file"
              fi
              
              # Check if this project already has an assigned port
              local assigned_port=$(jq -r ".[\"$project_name\"] // \"\"" "$port_config_file")
              
              if [ -n "$assigned_port" ] && [ "$assigned_port" != "null" ]; then
                echo "Project has previously assigned port: $assigned_port"
                # Verify the port is still available (not used by another process)
                if ! netstat -tuln | grep -q ":$assigned_port "; then
                  echo "Using previously assigned port: $assigned_port"
                  return $assigned_port
                else
                  echo "Previously assigned port $assigned_port is now in use by another process"
                  # Continue to find a new port
                fi
              fi
              
              # Use preferred port if specified and available
              if [ -n "$preferred_port" ] && ! netstat -tuln | grep -q ":$preferred_port "; then
                # Update port mapping file
                jq ".[\"$project_name\"] = \"$preferred_port\"" "$port_config_file" > "$port_config_file.tmp" && 
                mv "$port_config_file.tmp" "$port_config_file"
                echo "Using preferred port: $preferred_port"
                return $preferred_port
              fi
              
              # Find an available port in the range
              for port in $(seq $min_port $max_port); do
                if ! netstat -tuln | grep -q ":$port "; then
                  # Update port mapping file
                  jq ".[\"$project_name\"] = \"$port\"" "$port_config_file" > "$port_config_file.tmp" && 
                  mv "$port_config_file.tmp" "$port_config_file"
                  echo "Assigned new port: $port"
                  return $port
                fi
              done
              
              echo "ERROR: No available ports found in range $min_port-$max_port"
              exit 1
            }

            # Set variables from GitHub secrets
            export PROJECT_NAME="${{ secrets.PROJECT_NAME }}"
            export PROJECT_REPO="${{ secrets.PROJECT_REPO }}"
            export PROJECT_DOMAIN="${{ secrets.PROJECT_DOMAIN }}"

            # Get port dynamically or use preferred port from secrets if available
            PORT=$(find_available_port "$PROJECT_NAME" "${{ secrets.PROJECT_PORT || '' }}")
            export PORT

            echo "Using port $PORT for $PROJECT_NAME"
            export PROJECT_PATH="/var/www/${PROJECT_NAME}"
            export PM2_FILE_TYPE="${{ secrets.PM2_FILE_TYPE || 'cjs' }}"  # Default to cjs if not specified

            # Check for port conflicts
            if netstat -tuln | grep ":${PORT}" > /dev/null; then
              echo "WARNING: Port ${PORT} is already in use. Check for conflicts."
              # Continue but warn - you may want to fail here instead
            fi

            # Step 1: Clone or pull the latest version with error handling
            echo "Checking repository..."
            if [ -d "$PROJECT_PATH" ]; then
              echo "Repository exists, pulling latest changes..."
              cd $PROJECT_PATH || handle_error "Failed to change to project directory"
              git pull origin main || handle_error "Failed to pull latest code"
            else
              echo "Cloning repository..."
              mkdir -p $PROJECT_PATH || handle_error "Failed to create project directory"
              
              # Handle private repository authentication if needed
              if [[ "$PROJECT_REPO" == *"git@"* ]]; then
                # Ensure SSH agent is running for private repos
                eval $(ssh-agent) > /dev/null
                ssh-add ~/.ssh/id_rsa 2>/dev/null || echo "SSH key not added, ensure keys are configured"
              fi
              
              git clone $PROJECT_REPO $PROJECT_PATH || handle_error "Failed to clone repository"
              cd $PROJECT_PATH || handle_error "Failed to change to project directory" 
            fi

            # Step 2: Install dependencies
            echo "Installing dependencies..."
            cd $PROJECT_PATH || handle_error "Failed to change directory"
            npm install || handle_error "Failed to install dependencies"

            # Step 3: Create environment file from GitHub secrets BEFORE building
            echo "Checking for environment file changes..."
            cat << 'EOF' > /tmp/env-new
            ${{ secrets.ENV_FILE }}
            EOF

            if [ ! -f ".env" ] || ! cmp -s "/tmp/env-new" ".env"; then
              echo "Creating/updating .env file..."
              cp /tmp/env-new .env || handle_error "Failed to create .env file"
            else
              echo ".env file unchanged"
            fi
            rm /tmp/env-new

            # Step 4: Build the project with error handling
            echo "Building project..."
            npm run build || handle_error "Failed to build project"

            # Step 5: Configure PM2 ecosystem file
            echo "Checking for PM2 config changes..."
            PM2_FILE="ecosystem.config.${PM2_FILE_TYPE}"

            cat << EOF > /tmp/ecosystem-new.config
            module.exports = {
              apps: [
                {
                  name: "${PROJECT_NAME}",
                  script: "npm",
                  args: "start",
                  cwd: "${PROJECT_PATH}",
                  env: {
                    NODE_ENV: "production",
                    PORT: ${PORT},
                    ${{ secrets.PM2_ENV_VARS }}
                  },
                  // Error log file path
                  error_file: "${PROJECT_PATH}/logs/error.log",
                  // Out log file path
                  out_file: "${PROJECT_PATH}/logs/out.log",
                  // Enable/disable watch mode
                  watch: false,
                  // Max memory restart (if app exceeds this, PM2 will restart it)
                  max_memory_restart: "500M"
                }
              ]
            };
            EOF

            # Create logs directory if it doesn't exist
            mkdir -p "${PROJECT_PATH}/logs" || handle_error "Failed to create logs directory"

            # Only update if content differs or file doesn't exist
            if [ ! -f "$PM2_FILE" ] || ! cmp -s "/tmp/ecosystem-new.config" "$PM2_FILE"; then
              echo "Creating/updating PM2 ecosystem config..."
              cp /tmp/ecosystem-new.config "$PM2_FILE" || handle_error "Failed to create PM2 config"
            else
              echo "PM2 config unchanged"
            fi
            rm /tmp/ecosystem-new.config

            # Step 6: Create and configure Nginx - check for project-specific static dirs
            echo "Checking Nginx configuration..."

            # Check if custom directories exist
            HAS_UPLOADS=false
            if [ -d "${PROJECT_PATH}/public/uploads" ]; then
              HAS_UPLOADS=true
            fi

            # Create Nginx config
            cat << EOF > /tmp/nginx-${PROJECT_NAME}
            server {
              server_name ${PROJECT_DOMAIN};

              location / {
                proxy_pass http://localhost:${PORT};
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_cache_bypass \$http_upgrade;
              }
            EOF

            # Only add uploads location if directory exists
            if [ "$HAS_UPLOADS" = true ]; then
              cat << EOF >> /tmp/nginx-${PROJECT_NAME}
              
              location /uploads/ {
                alias ${PROJECT_PATH}/public/uploads/;
                access_log off;
                expires 1y;
                add_header Cache-Control "public";
              }
            EOF
            fi

            # Next.js static files
            if [ -d "${PROJECT_PATH}/.next/static" ]; then
              cat << EOF >> /tmp/nginx-${PROJECT_NAME}
              
              location /_next/static/ {
                alias ${PROJECT_PATH}/.next/static/;
                access_log off;
                expires 30d;
                add_header Cache-Control "public";
              }
            EOF
            fi

            # Public static files
            if [ -d "${PROJECT_PATH}/public/static" ]; then
              cat << EOF >> /tmp/nginx-${PROJECT_NAME}
              
              location /static/ {
                alias ${PROJECT_PATH}/public/static/;
                access_log off;
                expires 30d;
                add_header Cache-Control "public";
              }
            EOF
            fi

            # Complete the server block
            cat << EOF >> /tmp/nginx-${PROJECT_NAME}
            }

            server {
              listen 80;
              server_name ${PROJECT_DOMAIN};
              return 301 https://\$host\$request_uri;
            }
            EOF

            # Check if Nginx config already exists and compare
            NGINX_CONFIG_PATH="/etc/nginx/sites-available/${PROJECT_NAME}"

            if [ -f "$NGINX_CONFIG_PATH" ]; then
              # Compare with existing config
              if ! cmp -s "/tmp/nginx-${PROJECT_NAME}" "$NGINX_CONFIG_PATH"; then
                echo "Nginx configuration changed, updating..."
                sudo cp /tmp/nginx-${PROJECT_NAME} "$NGINX_CONFIG_PATH" || handle_error "Failed to update Nginx config"
              else
                echo "Nginx configuration unchanged"
              fi
            else
              # Create new config
              echo "Creating new Nginx configuration..."
              sudo cp /tmp/nginx-${PROJECT_NAME} "$NGINX_CONFIG_PATH" || handle_error "Failed to create Nginx config"
            fi

            rm /tmp/nginx-${PROJECT_NAME}

            # Create symbolic link if not exists
            if [ ! -f "/etc/nginx/sites-enabled/${PROJECT_NAME}" ]; then
              echo "Creating Nginx symbolic link..."
              sudo ln -s "$NGINX_CONFIG_PATH" "/etc/nginx/sites-enabled/${PROJECT_NAME}" || handle_error "Failed to create symbolic link"
            fi

            # Test Nginx configuration
            echo "Testing Nginx configuration..."
            sudo nginx -t || handle_error "Nginx configuration test failed"

            # Step 7: Restart/start PM2 process and reload Nginx
            echo "Starting/restarting services..."
            cd $PROJECT_PATH || handle_error "Failed to change directory"

            # Start or reload PM2 process with updated environment variables
            if pm2 list | grep -q "$PROJECT_NAME"; then
              echo "Reloading PM2 process with updated environment..."
              pm2 reload "$PM2_FILE" --update-env || handle_error "Failed to reload PM2 process"
            else
              echo "Starting PM2 process with fresh environment..."
              pm2 start "$PM2_FILE" --update-env || handle_error "Failed to start PM2 process"
            fi

            # Save PM2 process list
            pm2 save || echo "Warning: Could not save PM2 process list"

            # Restart Nginx only if necessary
            echo "Reloading Nginx..."
            sudo systemctl reload nginx || handle_error "Failed to reload Nginx"

            # Step 8: Set up or check SSL
            # Check if certificate exists and is not about to expire (less than 30 days)
            if [ ! -d "/etc/letsencrypt/live/${PROJECT_DOMAIN}" ] || 
               [ "$(sudo certbot certificates -d "${PROJECT_DOMAIN}" 2>/dev/null | grep 'VALID:' | grep -oP '\d+(?= days)' | head -1)" -lt "30" ]; then
              echo "Setting up or renewing SSL certificate..."
              sudo certbot --nginx -d "${PROJECT_DOMAIN}" --non-interactive --agree-tos \
                   --email ${{ secrets.SSL_EMAIL }} \
                   --keep-until-expiring --redirect || echo "Warning: SSL setup/renewal had issues"
            else
              echo "SSL certificate is valid and not near expiration"
            fi

            echo "Deployment completed successfully!"

            # ----- ROLLBACK MECHANISM -----
            # This function is called by the trap on ERR signal
            rollback() {
              local EXIT_CODE=$?
              local STEP=$1
              echo "ERROR: Deployment failed at step: $STEP with exit code: $EXIT_CODE"
              echo "Starting rollback procedure..."
              
              case $STEP in
                "repository")
                  echo "Rolling back repository changes..."
                  if [ -d "$PROJECT_PATH" ] && [ ! -d "$PROJECT_PATH/.git" ]; then
                    # Remove directory if it was just created without git initialization
                    echo "Removing incomplete project directory"
                    rm -rf "$PROJECT_PATH"
                  elif [ -d "$PROJECT_PATH/.git" ] && [ -f "$PROJECT_PATH/.git/ORIG_HEAD" ]; then
                    # Reset to previous state if git pull failed
                    echo "Resetting git repository to previous state"
                    cd "$PROJECT_PATH" && git reset --hard ORIG_HEAD
                  fi
                  ;;
                  
                "build")
                  echo "Rolling back failed build..."
                  if [ -d "$PROJECT_PATH/.next.bak" ]; then
                    echo "Restoring previous build"
                    rm -rf "$PROJECT_PATH/.next"
                    mv "$PROJECT_PATH/.next.bak" "$PROJECT_PATH/.next"
                  fi
                  ;;
                  
                "config")
                  echo "Rolling back configuration changes..."
                  # Restore .env if backup exists
                  if [ -f "$PROJECT_PATH/.env.bak" ]; then
                    mv "$PROJECT_PATH/.env.bak" "$PROJECT_PATH/.env"
                  fi
                  # Restore PM2 config if backup exists
                  if [ -f "$PROJECT_PATH/$PM2_FILE.bak" ]; then
                    mv "$PROJECT_PATH/$PM2_FILE.bak" "$PROJECT_PATH/$PM2_FILE"
                  fi
                  ;;
                  
                "nginx")
                  echo "Rolling back Nginx configuration..."
                  if [ -f "/etc/nginx/sites-available/${PROJECT_NAME}.bak" ]; then
                    sudo mv "/etc/nginx/sites-available/${PROJECT_NAME}.bak" "/etc/nginx/sites-available/${PROJECT_NAME}"
                    sudo systemctl reload nginx
                  elif [ -f "/etc/nginx/sites-available/${PROJECT_NAME}" ] && [ -z "$NGINX_EXISTED" ]; then
                    # If Nginx config was newly created, remove it
                    sudo rm -f "/etc/nginx/sites-available/${PROJECT_NAME}"
                    [ -L "/etc/nginx/sites-enabled/${PROJECT_NAME}" ] && sudo rm -f "/etc/nginx/sites-enabled/${PROJECT_NAME}"
                    sudo systemctl reload nginx
                  fi
                  ;;
                  
                "pm2")
                  echo "Rolling back PM2 process..."
                  if pm2 list | grep -q "$PROJECT_NAME"; then
                    if [ -n "$PM2_EXISTED" ]; then
                      # If PM2 process existed before, try to restore from backup
                      if [ -f "$PROJECT_PATH/$PM2_FILE.bak" ]; then
                        mv "$PROJECT_PATH/$PM2_FILE.bak" "$PROJECT_PATH/$PM2_FILE"
                        pm2 reload "$PM2_FILE" || pm2 restart "$PROJECT_NAME"
                      fi
                    else
                      # If PM2 process was newly created, stop and delete it
                      pm2 delete "$PROJECT_NAME"
                    fi
                    pm2 save
                  fi
                  ;;
                  
                *)
                  echo "No specific rollback action for step: $STEP"
                  ;;
              esac
              
              echo "Rollback completed. System state might require manual verification."
              exit $EXIT_CODE
            }

            # Replace the simple error handler with a rollback-enabled version
            handle_error() {
              rollback "$1"
            }

            # Create a better deployment flow with state tracking
            deploy() {
              # State tracking
              export NGINX_EXISTED=false
              export PM2_EXISTED=false
              
              echo "Starting deployment with rollback protection..."
              
              # Step 1: Repository state check and backup
              echo "Preparing repository..."
              if [ -d "$PROJECT_PATH" ]; then
                # Backup git state before pull
                cd "$PROJECT_PATH" || rollback "repository"
                git tag -f deployment-backup
                echo "Repository exists, pulling latest changes..."
                git pull origin main || rollback "repository"
              else
                echo "Cloning repository..."
                mkdir -p $PROJECT_PATH || rollback "repository"
                
                # Handle private repository authentication
                if [[ "$PROJECT_REPO" == *"git@"* ]]; then
                  eval $(ssh-agent) > /dev/null
                  ssh-add ~/.ssh/id_rsa 2>/dev/null || echo "SSH key not added, ensure keys are configured"
                fi
                
                git clone $PROJECT_REPO $PROJECT_PATH || rollback "repository"
              fi
              
              # Step 2: Environment file with backup
              echo "Configuring environment..."
              [ -f ".env" ] && cp .env .env.bak
              
              cat << 'EOF' > /tmp/env-new
              ${{ secrets.ENV_FILE }}
              EOF
              
              if [ ! -f ".env" ] || ! cmp -s "/tmp/env-new" ".env"; then
                cp /tmp/env-new .env || rollback "config"
              fi
              rm /tmp/env-new
              
              # Step 3: Install dependencies and build
              echo "Installing dependencies..."
              npm install || rollback "build"
              
              echo "Building project..."
              npm run build || rollback "build"
              
              # Remove backup after successful build
              [ -d ".next.bak" ] && rm -rf .next.bak
              
              # Step 4: Configure PM2 ecosystem file
              echo "Checking for PM2 config changes..."
              PM2_FILE="ecosystem.config.${PM2_FILE_TYPE}"

              cat << EOF > /tmp/ecosystem-new.config
              module.exports = {
                apps: [
                  {
                    name: "${PROJECT_NAME}",
                    script: "npm",
                    args: "start",
                    cwd: "${PROJECT_PATH}",
                    env: {
                      NODE_ENV: "production",
                      PORT: ${PORT},
                      ${{ secrets.PM2_ENV_VARS }}
                    },
                    // Error log file path
                    error_file: "${PROJECT_PATH}/logs/error.log",
                    // Out log file path
                    out_file: "${PROJECT_PATH}/logs/out.log",
                    // Enable/disable watch mode
                    watch: false,
                    // Max memory restart (if app exceeds this, PM2 will restart it)
                    max_memory_restart: "500M"
                  }
                ]
              };
              EOF

              # Create logs directory if it doesn't exist
              mkdir -p "${PROJECT_PATH}/logs" || handle_error "Failed to create logs directory"

              # Only update if content differs or file doesn't exist
              if [ ! -f "$PM2_FILE" ] || ! cmp -s "/tmp/ecosystem-new.config" "$PM2_FILE"; then
                echo "Creating/updating PM2 ecosystem config..."
                cp /tmp/ecosystem-new.config "$PM2_FILE" || handle_error "Failed to create PM2 config"
              else
                echo "PM2 config unchanged"
              fi
              rm /tmp/ecosystem-new.config

              # Step 5: Create and configure Nginx - check for project-specific static dirs
              echo "Checking Nginx configuration..."

              # Check if custom directories exist
              HAS_UPLOADS=false
              if [ -d "${PROJECT_PATH}/public/uploads" ]; then
                HAS_UPLOADS=true
              fi

              # Create Nginx config
              cat << EOF > /tmp/nginx-${PROJECT_NAME}
              server {
                server_name ${PROJECT_DOMAIN};

                location / {
                  proxy_pass http://localhost:${PORT};
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_cache_bypass \$http_upgrade;
                }
              EOF

              # Only add uploads location if directory exists
              if [ "$HAS_UPLOADS" = true ]; then
                cat << EOF >> /tmp/nginx-${PROJECT_NAME}
                
                location /uploads/ {
                  alias ${PROJECT_PATH}/public/uploads/;
                  access_log off;
                  expires 1y;
                  add_header Cache-Control "public";
                }
              EOF
              fi

              # Next.js static files
              if [ -d "${PROJECT_PATH}/.next/static" ]; then
                cat << EOF >> /tmp/nginx-${PROJECT_NAME}
                
                location /_next/static/ {
                  alias ${PROJECT_PATH}/.next/static/;
                  access_log off;
                  expires 30d;
                  add_header Cache-Control "public";
                }
              EOF
              fi

              # Public static files
              if [ -d "${PROJECT_PATH}/public/static" ]; then
                cat << EOF >> /tmp/nginx-${PROJECT_NAME}
                
                location /static/ {
                  alias ${PROJECT_PATH}/public/static/;
                  access_log off;
                  expires 30d;
                  add_header Cache-Control "public";
                }
              EOF
              fi

              # Complete the server block
              cat << EOF >> /tmp/nginx-${PROJECT_NAME}
              }

              server {
                listen 80;
                server_name ${PROJECT_DOMAIN};
                return 301 https://\$host\$request_uri;
              }
              EOF

              # Check if Nginx config already exists and compare
              NGINX_CONFIG_PATH="/etc/nginx/sites-available/${PROJECT_NAME}"

              if [ -f "$NGINX_CONFIG_PATH" ]; then
                # Compare with existing config
                if ! cmp -s "/tmp/nginx-${PROJECT_NAME}" "$NGINX_CONFIG_PATH"; then
                  echo "Nginx configuration changed, updating..."
                  sudo cp /tmp/nginx-${PROJECT_NAME} "$NGINX_CONFIG_PATH" || handle_error "Failed to update Nginx config"
                else
                  echo "Nginx configuration unchanged"
                fi
              else
                # Create new config
                echo "Creating new Nginx configuration..."
                sudo cp /tmp/nginx-${PROJECT_NAME} "$NGINX_CONFIG_PATH" || handle_error "Failed to create Nginx config"
              fi

              rm /tmp/nginx-${PROJECT_NAME}

              # Create symbolic link if not exists
              if [ ! -f "/etc/nginx/sites-enabled/${PROJECT_NAME}" ]; then
                echo "Creating Nginx symbolic link..."
                sudo ln -s "$NGINX_CONFIG_PATH" "/etc/nginx/sites-enabled/${PROJECT_NAME}" || handle_error "Failed to create symbolic link"
              fi

              # Test Nginx configuration
              echo "Testing Nginx configuration..."
              sudo nginx -t || handle_error "Nginx configuration test failed"

              # Step 6: Restart/start PM2 process and reload Nginx
              echo "Starting/restarting services..."
              cd $PROJECT_PATH || handle_error "Failed to change directory"

              # Start or reload PM2 process with updated environment variables
              if pm2 list | grep -q "$PROJECT_NAME"; then
                echo "Reloading PM2 process with updated environment..."
                pm2 reload "$PM2_FILE" --update-env || handle_error "Failed to reload PM2 process"
              else
                echo "Starting PM2 process with fresh environment..."
                pm2 start "$PM2_FILE" --update-env || handle_error "Failed to start PM2 process"
              fi

              # Save PM2 process list
              pm2 save || echo "Warning: Could not save PM2 process list"

              # Restart Nginx only if necessary
              echo "Reloading Nginx..."
              sudo systemctl reload nginx || handle_error "Failed to reload Nginx"

              # Step 7: Set up or check SSL
              # Check if certificate exists and is not about to expire (less than 30 days)
              if [ ! -d "/etc/letsencrypt/live/${PROJECT_DOMAIN}" ] || 
                 [ "$(sudo certbot certificates -d "${PROJECT_DOMAIN}" 2>/dev/null | grep 'VALID:' | grep -oP '\d+(?= days)' | head -1)" -lt "30" ]; then
                echo "Setting up or renewing SSL certificate..."
                sudo certbot --nginx -d "${PROJECT_DOMAIN}" --non-interactive --agree-tos \
                     --email ${{ secrets.SSL_EMAIL }} \
                     --keep-until-expiring --redirect || echo "Warning: SSL setup/renewal had issues"
              else
                echo "SSL certificate is valid and not near expiration"
              fi

              echo "Deployment completed successfully!"
            }

            # ----- ROLLBACK MECHANISM -----
            # This function is called by the trap on ERR signal
            rollback() {
              local EXIT_CODE=$?
              local STEP=$1
              echo "ERROR: Deployment failed at step: $STEP with exit code: $EXIT_CODE"
              echo "Starting rollback procedure..."
              
              case $STEP in
                "repository")
                  echo "Rolling back repository changes..."
                  if [ -d "$PROJECT_PATH" ] && [ ! -d "$PROJECT_PATH/.git" ]; then
                    # Remove directory if it was just created without git initialization
                    echo "Removing incomplete project directory"
                    rm -rf "$PROJECT_PATH"
                  elif [ -d "$PROJECT_PATH/.git" ] && [ -f "$PROJECT_PATH/.git/ORIG_HEAD" ]; then
                    # Reset to previous state if git pull failed
                    echo "Resetting git repository to previous state"
                    cd "$PROJECT_PATH" && git reset --hard ORIG_HEAD
                  fi
                  ;;
                  
                "build")
                  echo "Rolling back failed build..."
                  if [ -d "$PROJECT_PATH/.next.bak" ]; then
                    echo "Restoring previous build"
                    rm -rf "$PROJECT_PATH/.next"
                    mv "$PROJECT_PATH/.next.bak" "$PROJECT_PATH/.next"
                  fi
                  ;;
                  
                "config")
                  echo "Rolling back configuration changes..."
                  # Restore .env if backup exists
                  if [ -f "$PROJECT_PATH/.env.bak" ]; then
                    mv "$PROJECT_PATH/.env.bak" "$PROJECT_PATH/.env"
                  fi
                  # Restore PM2 config if backup exists
                  if [ -f "$PROJECT_PATH/$PM2_FILE.bak" ]; then
                    mv "$PROJECT_PATH/$PM2_FILE.bak" "$PROJECT_PATH/$PM2_FILE"
                  fi
                  ;;
                  
                "nginx")
                  echo "Rolling back Nginx configuration..."
                  if [ -f "/etc/nginx/sites-available/${PROJECT_NAME}.bak" ]; then
                    sudo mv "/etc/nginx/sites-available/${PROJECT_NAME}.bak" "/etc/nginx/sites-available/${PROJECT_NAME}"
                    sudo systemctl reload nginx
                  elif [ -f "/etc/nginx/sites-available/${PROJECT_NAME}" ] && [ -z "$NGINX_EXISTED" ]; then
                    # If Nginx config was newly created, remove it
                    sudo rm -f "/etc/nginx/sites-available/${PROJECT_NAME}"
                    [ -L "/etc/nginx/sites-enabled/${PROJECT_NAME}" ] && sudo rm -f "/etc/nginx/sites-enabled/${PROJECT_NAME}"
                    sudo systemctl reload nginx
                  fi
                  ;;
                  
                "pm2")
                  echo "Rolling back PM2 process..."
                  if pm2 list | grep -q "$PROJECT_NAME"; then
                    if [ -n "$PM2_EXISTED" ]; then
                      # If PM2 process existed before, try to restore from backup
                      if [ -f "$PROJECT_PATH/$PM2_FILE.bak" ]; then
                        mv "$PROJECT_PATH/$PM2_FILE.bak" "$PROJECT_PATH/$PM2_FILE"
                        pm2 reload "$PM2_FILE" || pm2 restart "$PROJECT_NAME"
                      fi
                    else
                      # If PM2 process was newly created, stop and delete it
                      pm2 delete "$PROJECT_NAME"
                    fi
                    pm2 save
                  fi
                  ;;
                  
                *)
                  echo "No specific rollback action for step: $STEP"
                  ;;
              esac
              
              echo "Rollback completed. System state might require manual verification."
              exit $EXIT_CODE
            }

            # Add trap for unexpected failures
            trap 'rollback "unexpected"' ERR

            # Uncomment to use the improved deployment flow
            # deploy
